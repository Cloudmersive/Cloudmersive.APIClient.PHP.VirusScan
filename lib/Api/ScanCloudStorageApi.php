<?php
/**
 * ScanCloudStorageApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * virusapi
 *
 * The Cloudmersive Virus Scan API lets you scan files and content for viruses and identify security issues with content.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.32
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ScanCloudStorageApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ScanCloudStorageApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation scanCloudStorageScanAwsS3File
     *
     * Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageVirusScanResult
     */
    public function scanCloudStorageScanAwsS3File($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
    {
        list($response) = $this->scanCloudStorageScanAwsS3FileWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileWithHttpInfo
     *
     * Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanAwsS3FileWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanAwsS3FileRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAsync
     *
     * Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAwsS3FileAsync($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
    {
        return $this->scanCloudStorageScanAwsS3FileAsyncWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAsyncWithHttpInfo
     *
     * Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAwsS3FileAsyncWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanAwsS3FileRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanAwsS3File'
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanAwsS3FileRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name)
    {
        // verify the required parameter 'access_key' is set
        if ($access_key === null || (is_array($access_key) && count($access_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $access_key when calling scanCloudStorageScanAwsS3File'
            );
        }
        // verify the required parameter 'secret_key' is set
        if ($secret_key === null || (is_array($secret_key) && count($secret_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_key when calling scanCloudStorageScanAwsS3File'
            );
        }
        // verify the required parameter 'bucket_region' is set
        if ($bucket_region === null || (is_array($bucket_region) && count($bucket_region) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_region when calling scanCloudStorageScanAwsS3File'
            );
        }
        // verify the required parameter 'bucket_name' is set
        if ($bucket_name === null || (is_array($bucket_name) && count($bucket_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_name when calling scanCloudStorageScanAwsS3File'
            );
        }
        // verify the required parameter 'key_name' is set
        if ($key_name === null || (is_array($key_name) && count($key_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key_name when calling scanCloudStorageScanAwsS3File'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/aws-s3/single';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($access_key !== null) {
            $headerParams['accessKey'] = ObjectSerializer::toHeaderValue($access_key);
        }
        // header params
        if ($secret_key !== null) {
            $headerParams['secretKey'] = ObjectSerializer::toHeaderValue($secret_key);
        }
        // header params
        if ($bucket_region !== null) {
            $headerParams['bucketRegion'] = ObjectSerializer::toHeaderValue($bucket_region);
        }
        // header params
        if ($bucket_name !== null) {
            $headerParams['bucketName'] = ObjectSerializer::toHeaderValue($bucket_name);
        }
        // header params
        if ($key_name !== null) {
            $headerParams['keyName'] = ObjectSerializer::toHeaderValue($key_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAdvanced
     *
     * Advanced Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult
     */
    public function scanCloudStorageScanAwsS3FileAdvanced($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        list($response) = $this->scanCloudStorageScanAwsS3FileAdvancedWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAdvancedWithHttpInfo
     *
     * Advanced Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanAwsS3FileAdvancedWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanAwsS3FileAdvancedRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAdvancedAsync
     *
     * Advanced Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAwsS3FileAdvancedAsync($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        return $this->scanCloudStorageScanAwsS3FileAdvancedAsyncWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanAwsS3FileAdvancedAsyncWithHttpInfo
     *
     * Advanced Scan an AWS S3 file for viruses
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAwsS3FileAdvancedAsyncWithHttpInfo($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanAwsS3FileAdvancedRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanAwsS3FileAdvanced'
     *
     * @param  string $access_key AWS S3 access key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $secret_key AWS S3 secret key for the S3 bucket; you can get this from My Security Credentials in the AWS console (required)
     * @param  string $bucket_region Name of the region of the S3 bucket, such as &#39;US-East-1&#39; (required)
     * @param  string $bucket_name Name of the S3 bucket (required)
     * @param  string $key_name Key name (also called file name) of the file in S3 that you wish to scan for viruses.  If the key name contains Unicode characters, you must base64 encode the key name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanAwsS3FileAdvancedRequest($access_key, $secret_key, $bucket_region, $bucket_name, $key_name, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        // verify the required parameter 'access_key' is set
        if ($access_key === null || (is_array($access_key) && count($access_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $access_key when calling scanCloudStorageScanAwsS3FileAdvanced'
            );
        }
        // verify the required parameter 'secret_key' is set
        if ($secret_key === null || (is_array($secret_key) && count($secret_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_key when calling scanCloudStorageScanAwsS3FileAdvanced'
            );
        }
        // verify the required parameter 'bucket_region' is set
        if ($bucket_region === null || (is_array($bucket_region) && count($bucket_region) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_region when calling scanCloudStorageScanAwsS3FileAdvanced'
            );
        }
        // verify the required parameter 'bucket_name' is set
        if ($bucket_name === null || (is_array($bucket_name) && count($bucket_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_name when calling scanCloudStorageScanAwsS3FileAdvanced'
            );
        }
        // verify the required parameter 'key_name' is set
        if ($key_name === null || (is_array($key_name) && count($key_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key_name when calling scanCloudStorageScanAwsS3FileAdvanced'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/aws-s3/single/advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($access_key !== null) {
            $headerParams['accessKey'] = ObjectSerializer::toHeaderValue($access_key);
        }
        // header params
        if ($secret_key !== null) {
            $headerParams['secretKey'] = ObjectSerializer::toHeaderValue($secret_key);
        }
        // header params
        if ($bucket_region !== null) {
            $headerParams['bucketRegion'] = ObjectSerializer::toHeaderValue($bucket_region);
        }
        // header params
        if ($bucket_name !== null) {
            $headerParams['bucketName'] = ObjectSerializer::toHeaderValue($bucket_name);
        }
        // header params
        if ($key_name !== null) {
            $headerParams['keyName'] = ObjectSerializer::toHeaderValue($key_name);
        }
        // header params
        if ($allow_executables !== null) {
            $headerParams['allowExecutables'] = ObjectSerializer::toHeaderValue($allow_executables);
        }
        // header params
        if ($allow_invalid_files !== null) {
            $headerParams['allowInvalidFiles'] = ObjectSerializer::toHeaderValue($allow_invalid_files);
        }
        // header params
        if ($allow_scripts !== null) {
            $headerParams['allowScripts'] = ObjectSerializer::toHeaderValue($allow_scripts);
        }
        // header params
        if ($allow_password_protected_files !== null) {
            $headerParams['allowPasswordProtectedFiles'] = ObjectSerializer::toHeaderValue($allow_password_protected_files);
        }
        // header params
        if ($allow_macros !== null) {
            $headerParams['allowMacros'] = ObjectSerializer::toHeaderValue($allow_macros);
        }
        // header params
        if ($allow_xml_external_entities !== null) {
            $headerParams['allowXmlExternalEntities'] = ObjectSerializer::toHeaderValue($allow_xml_external_entities);
        }
        // header params
        if ($allow_insecure_deserialization !== null) {
            $headerParams['allowInsecureDeserialization'] = ObjectSerializer::toHeaderValue($allow_insecure_deserialization);
        }
        // header params
        if ($allow_html !== null) {
            $headerParams['allowHtml'] = ObjectSerializer::toHeaderValue($allow_html);
        }
        // header params
        if ($restrict_file_types !== null) {
            $headerParams['restrictFileTypes'] = ObjectSerializer::toHeaderValue($restrict_file_types);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanAzureBlob
     *
     * Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageVirusScanResult
     */
    public function scanCloudStorageScanAzureBlob($connection_string, $container_name, $blob_path)
    {
        list($response) = $this->scanCloudStorageScanAzureBlobWithHttpInfo($connection_string, $container_name, $blob_path);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanAzureBlobWithHttpInfo
     *
     * Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanAzureBlobWithHttpInfo($connection_string, $container_name, $blob_path)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanAzureBlobRequest($connection_string, $container_name, $blob_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAsync
     *
     * Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAzureBlobAsync($connection_string, $container_name, $blob_path)
    {
        return $this->scanCloudStorageScanAzureBlobAsyncWithHttpInfo($connection_string, $container_name, $blob_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAsyncWithHttpInfo
     *
     * Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAzureBlobAsyncWithHttpInfo($connection_string, $container_name, $blob_path)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanAzureBlobRequest($connection_string, $container_name, $blob_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanAzureBlob'
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanAzureBlobRequest($connection_string, $container_name, $blob_path)
    {
        // verify the required parameter 'connection_string' is set
        if ($connection_string === null || (is_array($connection_string) && count($connection_string) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_string when calling scanCloudStorageScanAzureBlob'
            );
        }
        // verify the required parameter 'container_name' is set
        if ($container_name === null || (is_array($container_name) && count($container_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container_name when calling scanCloudStorageScanAzureBlob'
            );
        }
        // verify the required parameter 'blob_path' is set
        if ($blob_path === null || (is_array($blob_path) && count($blob_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blob_path when calling scanCloudStorageScanAzureBlob'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/azure-blob/single';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($connection_string !== null) {
            $headerParams['connectionString'] = ObjectSerializer::toHeaderValue($connection_string);
        }
        // header params
        if ($container_name !== null) {
            $headerParams['containerName'] = ObjectSerializer::toHeaderValue($container_name);
        }
        // header params
        if ($blob_path !== null) {
            $headerParams['blobPath'] = ObjectSerializer::toHeaderValue($blob_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAdvanced
     *
     * Advanced Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult
     */
    public function scanCloudStorageScanAzureBlobAdvanced($connection_string, $container_name, $blob_path, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        list($response) = $this->scanCloudStorageScanAzureBlobAdvancedWithHttpInfo($connection_string, $container_name, $blob_path, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAdvancedWithHttpInfo
     *
     * Advanced Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanAzureBlobAdvancedWithHttpInfo($connection_string, $container_name, $blob_path, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanAzureBlobAdvancedRequest($connection_string, $container_name, $blob_path, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAdvancedAsync
     *
     * Advanced Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAzureBlobAdvancedAsync($connection_string, $container_name, $blob_path, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        return $this->scanCloudStorageScanAzureBlobAdvancedAsyncWithHttpInfo($connection_string, $container_name, $blob_path, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanAzureBlobAdvancedAsyncWithHttpInfo
     *
     * Advanced Scan an Azure Blob for viruses
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanAzureBlobAdvancedAsyncWithHttpInfo($connection_string, $container_name, $blob_path, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanAzureBlobAdvancedRequest($connection_string, $container_name, $blob_path, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanAzureBlobAdvanced'
     *
     * @param  string $connection_string Connection string for the Azure Blob Storage Account; you can get this connection string from the Access Keys tab of the Storage Account blade in the Azure Portal. (required)
     * @param  string $container_name Name of the Blob container within the Azure Blob Storage account (required)
     * @param  string $blob_path Path to the blob within the container, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the blob path contains Unicode characters, you must base64 encode the blob path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanAzureBlobAdvancedRequest($connection_string, $container_name, $blob_path, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        // verify the required parameter 'connection_string' is set
        if ($connection_string === null || (is_array($connection_string) && count($connection_string) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_string when calling scanCloudStorageScanAzureBlobAdvanced'
            );
        }
        // verify the required parameter 'container_name' is set
        if ($container_name === null || (is_array($container_name) && count($container_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container_name when calling scanCloudStorageScanAzureBlobAdvanced'
            );
        }
        // verify the required parameter 'blob_path' is set
        if ($blob_path === null || (is_array($blob_path) && count($blob_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blob_path when calling scanCloudStorageScanAzureBlobAdvanced'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/azure-blob/single/advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($connection_string !== null) {
            $headerParams['connectionString'] = ObjectSerializer::toHeaderValue($connection_string);
        }
        // header params
        if ($container_name !== null) {
            $headerParams['containerName'] = ObjectSerializer::toHeaderValue($container_name);
        }
        // header params
        if ($blob_path !== null) {
            $headerParams['blobPath'] = ObjectSerializer::toHeaderValue($blob_path);
        }
        // header params
        if ($allow_executables !== null) {
            $headerParams['allowExecutables'] = ObjectSerializer::toHeaderValue($allow_executables);
        }
        // header params
        if ($allow_invalid_files !== null) {
            $headerParams['allowInvalidFiles'] = ObjectSerializer::toHeaderValue($allow_invalid_files);
        }
        // header params
        if ($allow_scripts !== null) {
            $headerParams['allowScripts'] = ObjectSerializer::toHeaderValue($allow_scripts);
        }
        // header params
        if ($allow_password_protected_files !== null) {
            $headerParams['allowPasswordProtectedFiles'] = ObjectSerializer::toHeaderValue($allow_password_protected_files);
        }
        // header params
        if ($allow_macros !== null) {
            $headerParams['allowMacros'] = ObjectSerializer::toHeaderValue($allow_macros);
        }
        // header params
        if ($allow_xml_external_entities !== null) {
            $headerParams['allowXmlExternalEntities'] = ObjectSerializer::toHeaderValue($allow_xml_external_entities);
        }
        // header params
        if ($allow_insecure_deserialization !== null) {
            $headerParams['allowInsecureDeserialization'] = ObjectSerializer::toHeaderValue($allow_insecure_deserialization);
        }
        // header params
        if ($allow_html !== null) {
            $headerParams['allowHtml'] = ObjectSerializer::toHeaderValue($allow_html);
        }
        // header params
        if ($restrict_file_types !== null) {
            $headerParams['restrictFileTypes'] = ObjectSerializer::toHeaderValue($restrict_file_types);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFile
     *
     * Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageVirusScanResult
     */
    public function scanCloudStorageScanGcpStorageFile($bucket_name, $object_name, $json_credential_file)
    {
        list($response) = $this->scanCloudStorageScanGcpStorageFileWithHttpInfo($bucket_name, $object_name, $json_credential_file);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileWithHttpInfo
     *
     * Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanGcpStorageFileWithHttpInfo($bucket_name, $object_name, $json_credential_file)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanGcpStorageFileRequest($bucket_name, $object_name, $json_credential_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAsync
     *
     * Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanGcpStorageFileAsync($bucket_name, $object_name, $json_credential_file)
    {
        return $this->scanCloudStorageScanGcpStorageFileAsyncWithHttpInfo($bucket_name, $object_name, $json_credential_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAsyncWithHttpInfo
     *
     * Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanGcpStorageFileAsyncWithHttpInfo($bucket_name, $object_name, $json_credential_file)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanGcpStorageFileRequest($bucket_name, $object_name, $json_credential_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanGcpStorageFile'
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanGcpStorageFileRequest($bucket_name, $object_name, $json_credential_file)
    {
        // verify the required parameter 'bucket_name' is set
        if ($bucket_name === null || (is_array($bucket_name) && count($bucket_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_name when calling scanCloudStorageScanGcpStorageFile'
            );
        }
        // verify the required parameter 'object_name' is set
        if ($object_name === null || (is_array($object_name) && count($object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_name when calling scanCloudStorageScanGcpStorageFile'
            );
        }
        // verify the required parameter 'json_credential_file' is set
        if ($json_credential_file === null || (is_array($json_credential_file) && count($json_credential_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $json_credential_file when calling scanCloudStorageScanGcpStorageFile'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/gcp-storage/single';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($bucket_name !== null) {
            $headerParams['bucketName'] = ObjectSerializer::toHeaderValue($bucket_name);
        }
        // header params
        if ($object_name !== null) {
            $headerParams['objectName'] = ObjectSerializer::toHeaderValue($object_name);
        }


        // form params
        if ($json_credential_file !== null) {
            $multipart = true;
            $formParams['jsonCredentialFile'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($json_credential_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAdvanced
     *
     * Advanced Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult
     */
    public function scanCloudStorageScanGcpStorageFileAdvanced($bucket_name, $object_name, $json_credential_file, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        list($response) = $this->scanCloudStorageScanGcpStorageFileAdvancedWithHttpInfo($bucket_name, $object_name, $json_credential_file, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAdvancedWithHttpInfo
     *
     * Advanced Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanGcpStorageFileAdvancedWithHttpInfo($bucket_name, $object_name, $json_credential_file, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanGcpStorageFileAdvancedRequest($bucket_name, $object_name, $json_credential_file, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAdvancedAsync
     *
     * Advanced Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanGcpStorageFileAdvancedAsync($bucket_name, $object_name, $json_credential_file, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        return $this->scanCloudStorageScanGcpStorageFileAdvancedAsyncWithHttpInfo($bucket_name, $object_name, $json_credential_file, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanGcpStorageFileAdvancedAsyncWithHttpInfo
     *
     * Advanced Scan an Google Cloud Platform (GCP) Storage file for viruses
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanGcpStorageFileAdvancedAsyncWithHttpInfo($bucket_name, $object_name, $json_credential_file, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanGcpStorageFileAdvancedRequest($bucket_name, $object_name, $json_credential_file, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanGcpStorageFileAdvanced'
     *
     * @param  string $bucket_name Name of the bucket in Google Cloud Storage (required)
     * @param  string $object_name Name of the object or file in Google Cloud Storage.  If the object name contains Unicode characters, you must base64 encode the object name and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  \SplFileObject $json_credential_file Service Account credential for Google Cloud stored in a JSON file. (required)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanGcpStorageFileAdvancedRequest($bucket_name, $object_name, $json_credential_file, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        // verify the required parameter 'bucket_name' is set
        if ($bucket_name === null || (is_array($bucket_name) && count($bucket_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bucket_name when calling scanCloudStorageScanGcpStorageFileAdvanced'
            );
        }
        // verify the required parameter 'object_name' is set
        if ($object_name === null || (is_array($object_name) && count($object_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_name when calling scanCloudStorageScanGcpStorageFileAdvanced'
            );
        }
        // verify the required parameter 'json_credential_file' is set
        if ($json_credential_file === null || (is_array($json_credential_file) && count($json_credential_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $json_credential_file when calling scanCloudStorageScanGcpStorageFileAdvanced'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/gcp-storage/single/advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($bucket_name !== null) {
            $headerParams['bucketName'] = ObjectSerializer::toHeaderValue($bucket_name);
        }
        // header params
        if ($object_name !== null) {
            $headerParams['objectName'] = ObjectSerializer::toHeaderValue($object_name);
        }
        // header params
        if ($allow_executables !== null) {
            $headerParams['allowExecutables'] = ObjectSerializer::toHeaderValue($allow_executables);
        }
        // header params
        if ($allow_invalid_files !== null) {
            $headerParams['allowInvalidFiles'] = ObjectSerializer::toHeaderValue($allow_invalid_files);
        }
        // header params
        if ($allow_scripts !== null) {
            $headerParams['allowScripts'] = ObjectSerializer::toHeaderValue($allow_scripts);
        }
        // header params
        if ($allow_password_protected_files !== null) {
            $headerParams['allowPasswordProtectedFiles'] = ObjectSerializer::toHeaderValue($allow_password_protected_files);
        }
        // header params
        if ($allow_macros !== null) {
            $headerParams['allowMacros'] = ObjectSerializer::toHeaderValue($allow_macros);
        }
        // header params
        if ($allow_xml_external_entities !== null) {
            $headerParams['allowXmlExternalEntities'] = ObjectSerializer::toHeaderValue($allow_xml_external_entities);
        }
        // header params
        if ($allow_insecure_deserialization !== null) {
            $headerParams['allowInsecureDeserialization'] = ObjectSerializer::toHeaderValue($allow_insecure_deserialization);
        }
        // header params
        if ($allow_html !== null) {
            $headerParams['allowHtml'] = ObjectSerializer::toHeaderValue($allow_html);
        }
        // header params
        if ($restrict_file_types !== null) {
            $headerParams['restrictFileTypes'] = ObjectSerializer::toHeaderValue($restrict_file_types);
        }


        // form params
        if ($json_credential_file !== null) {
            $multipart = true;
            $formParams['jsonCredentialFile'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($json_credential_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFile
     *
     * Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageVirusScanResult
     */
    public function scanCloudStorageScanSharePointOnlineFile($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id = null, $item_id = null)
    {
        list($response) = $this->scanCloudStorageScanSharePointOnlineFileWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id, $item_id);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileWithHttpInfo
     *
     * Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanSharePointOnlineFileWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id = null, $item_id = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanSharePointOnlineFileRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAsync
     *
     * Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanSharePointOnlineFileAsync($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id = null, $item_id = null)
    {
        return $this->scanCloudStorageScanSharePointOnlineFileAsyncWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAsyncWithHttpInfo
     *
     * Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanSharePointOnlineFileAsyncWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id = null, $item_id = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageVirusScanResult';
        $request = $this->scanCloudStorageScanSharePointOnlineFileRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanSharePointOnlineFile'
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanSharePointOnlineFileRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $file_path, $tenant_id = null, $item_id = null)
    {
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling scanCloudStorageScanSharePointOnlineFile'
            );
        }
        // verify the required parameter 'client_secret' is set
        if ($client_secret === null || (is_array($client_secret) && count($client_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_secret when calling scanCloudStorageScanSharePointOnlineFile'
            );
        }
        // verify the required parameter 'sharepoint_domain_name' is set
        if ($sharepoint_domain_name === null || (is_array($sharepoint_domain_name) && count($sharepoint_domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharepoint_domain_name when calling scanCloudStorageScanSharePointOnlineFile'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling scanCloudStorageScanSharePointOnlineFile'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling scanCloudStorageScanSharePointOnlineFile'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/sharepoint-online/site/single';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($client_id !== null) {
            $headerParams['clientID'] = ObjectSerializer::toHeaderValue($client_id);
        }
        // header params
        if ($client_secret !== null) {
            $headerParams['clientSecret'] = ObjectSerializer::toHeaderValue($client_secret);
        }
        // header params
        if ($sharepoint_domain_name !== null) {
            $headerParams['sharepointDomainName'] = ObjectSerializer::toHeaderValue($sharepoint_domain_name);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteID'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($tenant_id !== null) {
            $headerParams['tenantID'] = ObjectSerializer::toHeaderValue($tenant_id);
        }
        // header params
        if ($file_path !== null) {
            $headerParams['filePath'] = ObjectSerializer::toHeaderValue($file_path);
        }
        // header params
        if ($item_id !== null) {
            $headerParams['itemID'] = ObjectSerializer::toHeaderValue($item_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAdvanced
     *
     * Advanced Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult
     */
    public function scanCloudStorageScanSharePointOnlineFileAdvanced($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id = null, $file_path = null, $item_id = null, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        list($response) = $this->scanCloudStorageScanSharePointOnlineFileAdvancedWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id, $file_path, $item_id, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);
        return $response;
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAdvancedWithHttpInfo
     *
     * Advanced Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloudStorageAdvancedVirusScanResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function scanCloudStorageScanSharePointOnlineFileAdvancedWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id = null, $file_path = null, $item_id = null, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanSharePointOnlineFileAdvancedRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id, $file_path, $item_id, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAdvancedAsync
     *
     * Advanced Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanSharePointOnlineFileAdvancedAsync($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id = null, $file_path = null, $item_id = null, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        return $this->scanCloudStorageScanSharePointOnlineFileAdvancedAsyncWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id, $file_path, $item_id, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scanCloudStorageScanSharePointOnlineFileAdvancedAsyncWithHttpInfo
     *
     * Advanced Virus Scan a file in a SharePoint Online Site Drive
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scanCloudStorageScanSharePointOnlineFileAdvancedAsyncWithHttpInfo($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id = null, $file_path = null, $item_id = null, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        $returnType = '\Swagger\Client\Model\CloudStorageAdvancedVirusScanResult';
        $request = $this->scanCloudStorageScanSharePointOnlineFileAdvancedRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id, $file_path, $item_id, $allow_executables, $allow_invalid_files, $allow_scripts, $allow_password_protected_files, $allow_macros, $allow_xml_external_entities, $allow_insecure_deserialization, $allow_html, $restrict_file_types);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scanCloudStorageScanSharePointOnlineFileAdvanced'
     *
     * @param  string $client_id Client ID access credentials; see description above for instructions on how to get the Client ID from the Azure Active Directory portal. (required)
     * @param  string $client_secret Client Secret access credentials; see description above for instructions on how to get the Client Secret from the Azure Active Directory portal (required)
     * @param  string $sharepoint_domain_name SharePoint Online domain name, such as mydomain.sharepoint.com (required)
     * @param  string $site_id Site ID (GUID) of the SharePoint site you wish to retrieve the file from (required)
     * @param  string $tenant_id Optional; Tenant ID of your Azure Active Directory (optional)
     * @param  string $file_path Path to the file within the drive, such as &#39;hello.pdf&#39; or &#39;/folder/subfolder/world.pdf&#39;.  If the file path contains Unicode characters, you must base64 encode the file path and prepend it with &#39;base64:&#39;, such as: &#39;base64:6ZWV6ZWV6ZWV6ZWV6ZWV6ZWV&#39;. (optional)
     * @param  string $item_id SharePoint itemID, such as a DriveItem Id (optional)
     * @param  bool $allow_executables Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)
     * @param  bool $allow_invalid_files Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)
     * @param  bool $allow_scripts Set to false to block script files, such as a PHP files, Python scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_password_protected_files Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_macros Set to false to block macros and other threats embedded in document files, such as Word, Excel and PowerPoint embedded Macros, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_xml_external_entities Set to false to block XML External Entities and other threats embedded in XML files, and other files that contain embedded content threats. Set to true to allow these file types. Default is false (recommended). (optional)
     * @param  bool $allow_insecure_deserialization Set to false to block Insecure Deserialization and other threats embedded in JSON and other object serialization files, and other files that contain embedded content threats.  Set to true to allow these file types.  Default is false (recommended). (optional)
     * @param  bool $allow_html Set to false to block HTML input in the top level file; HTML can contain XSS, scripts, local file accesses and other threats.  Set to true to allow these file types.  Default is false (recommended) [for API keys created prior to the release of this feature default is true for backward compatability]. (optional)
     * @param  string $restrict_file_types Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function scanCloudStorageScanSharePointOnlineFileAdvancedRequest($client_id, $client_secret, $sharepoint_domain_name, $site_id, $tenant_id = null, $file_path = null, $item_id = null, $allow_executables = null, $allow_invalid_files = null, $allow_scripts = null, $allow_password_protected_files = null, $allow_macros = null, $allow_xml_external_entities = null, $allow_insecure_deserialization = null, $allow_html = null, $restrict_file_types = null)
    {
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling scanCloudStorageScanSharePointOnlineFileAdvanced'
            );
        }
        // verify the required parameter 'client_secret' is set
        if ($client_secret === null || (is_array($client_secret) && count($client_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_secret when calling scanCloudStorageScanSharePointOnlineFileAdvanced'
            );
        }
        // verify the required parameter 'sharepoint_domain_name' is set
        if ($sharepoint_domain_name === null || (is_array($sharepoint_domain_name) && count($sharepoint_domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharepoint_domain_name when calling scanCloudStorageScanSharePointOnlineFileAdvanced'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling scanCloudStorageScanSharePointOnlineFileAdvanced'
            );
        }

        $resourcePath = '/virus/scan/cloud-storage/sharepoint-online/site/advanced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($client_id !== null) {
            $headerParams['clientID'] = ObjectSerializer::toHeaderValue($client_id);
        }
        // header params
        if ($client_secret !== null) {
            $headerParams['clientSecret'] = ObjectSerializer::toHeaderValue($client_secret);
        }
        // header params
        if ($sharepoint_domain_name !== null) {
            $headerParams['sharepointDomainName'] = ObjectSerializer::toHeaderValue($sharepoint_domain_name);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteID'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($tenant_id !== null) {
            $headerParams['tenantID'] = ObjectSerializer::toHeaderValue($tenant_id);
        }
        // header params
        if ($file_path !== null) {
            $headerParams['filePath'] = ObjectSerializer::toHeaderValue($file_path);
        }
        // header params
        if ($item_id !== null) {
            $headerParams['itemID'] = ObjectSerializer::toHeaderValue($item_id);
        }
        // header params
        if ($allow_executables !== null) {
            $headerParams['allowExecutables'] = ObjectSerializer::toHeaderValue($allow_executables);
        }
        // header params
        if ($allow_invalid_files !== null) {
            $headerParams['allowInvalidFiles'] = ObjectSerializer::toHeaderValue($allow_invalid_files);
        }
        // header params
        if ($allow_scripts !== null) {
            $headerParams['allowScripts'] = ObjectSerializer::toHeaderValue($allow_scripts);
        }
        // header params
        if ($allow_password_protected_files !== null) {
            $headerParams['allowPasswordProtectedFiles'] = ObjectSerializer::toHeaderValue($allow_password_protected_files);
        }
        // header params
        if ($allow_macros !== null) {
            $headerParams['allowMacros'] = ObjectSerializer::toHeaderValue($allow_macros);
        }
        // header params
        if ($allow_xml_external_entities !== null) {
            $headerParams['allowXmlExternalEntities'] = ObjectSerializer::toHeaderValue($allow_xml_external_entities);
        }
        // header params
        if ($allow_insecure_deserialization !== null) {
            $headerParams['allowInsecureDeserialization'] = ObjectSerializer::toHeaderValue($allow_insecure_deserialization);
        }
        // header params
        if ($allow_html !== null) {
            $headerParams['allowHtml'] = ObjectSerializer::toHeaderValue($allow_html);
        }
        // header params
        if ($restrict_file_types !== null) {
            $headerParams['restrictFileTypes'] = ObjectSerializer::toHeaderValue($restrict_file_types);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
